{
  "problem_id": "No7.c",
  "difficulty": "6",
  "description": "与えられた2つの整数の配列を結合し、新しい配列を作成する関数`merge_arrays`を実装してください。\n\n関数`merge_arrays`は、以下の引数を受け取ります。\n\n- `arr1`: 1つ目の整数配列\n- `size1`: `arr1`の要素数\n- `arr2`: 2つ目の整数配列\n- `size2`: `arr2`の要素数\n\n関数`merge_arrays`は、`arr1`と`arr2`を結合した新しい配列へのポインタを返します。新しい配列は、`arr1`の要素の後に`arr2`の要素が続くように配置されます。\n\n新しい配列のためのメモリは、関数内で動的に割り当てる必要があります。関数の呼び出し元は、`free`関数を使用して、この動的に割り当てられたメモリを解放する必要があります。\n\n例えば、`arr1`が`{1, 2, 3}`、`size1`が3、`arr2`が`{4, 5, 6}`、`size2`が3の場合、`merge_arrays`は`{1, 2, 3, 4, 5, 6}`を含む新しい配列へのポインタを返します。",
  "reason": "学習者は、`No4.c`において動的メモリ割り当てと配列操作の基本的な理解を示しています。しかし、`No5.c`と`No6.c`は未解答であり、2次元配列や文字列操作といった、より複雑なポインタ操作には課題があると考えられます。\n\nこの問題は、`No4.c`で示された動的メモリ割り当てと配列操作の知識を基に、複数の配列を扱う能力を評価します。また、メモリ管理の責任を呼び出し元に明確にすることで、メモリリークの危険性を理解しているかを評価します。\n\nこの問題は、1次元配列に限定することで、2次元配列の複雑さを避けつつ、ポインタ操作と動的メモリ割り当ての理解を深めるための適切な難易度となっています。",
  "examples": [
    {
      "input": "arr1 = {1, 2, 3}, size1 = 3, arr2 = {4, 5, 6}, size2 = 3",
      "output": "{1, 2, 3, 4, 5, 6}",
      "explanation": "2つの配列`arr1`と`arr2`が結合され、新しい配列が作成されます。"
    },
    {
      "input": "arr1 = {10, 20}, size1 = 2, arr2 = {30, 40, 50}, size2 = 3",
      "output": "{10, 20, 30, 40, 50}",
      "explanation": "異なるサイズの配列も正しく結合されます。"
    },
    {
      "input": "arr1 = {}, size1 = 0, arr2 = {1, 2}, size2 = 2",
      "output": "{1, 2}",
      "explanation": "空の配列を扱う場合も正しく動作します。"
    }
  ],
  "learning_objectives": [
    "動的メモリ割り当て",
    "配列操作",
    "ポインタ",
    "メモリ管理"
  ]
}