{
  "problem_id": "No7.c",
  "difficulty": 7,
  "description": "与えられた2つの整数の配列を結合し、新しい配列を返す関数を作成してください。新しい配列は動的に確保し、元の配列は変更しないようにしてください。\n\n関数プロトタイプ:\n```c\nint* merge_arrays(int arr1[], int size1, int arr2[], int size2, int *merged_size);\n```\n\n- `arr1`: 1つ目の配列\n- `size1`: 1つ目の配列のサイズ\n- `arr2`: 2つ目の配列\n- `size2`: 2つ目の配列のサイズ\n- `merged_size`: 結合後の配列のサイズを格納するためのポインタ\n\n戻り値:\n- 結合後の新しい配列へのポインタ。メモリ確保に失敗した場合はNULLを返す。\n\n例:\n```\narr1 = {1, 2, 3}\nsize1 = 3\narr2 = {4, 5, 6}\nsize2 = 3\n\n戻り値: {1, 2, 3, 4, 5, 6}\n*merged_size = 6\n```",
  "reason": "学習者は、1次元配列と2次元配列の動的確保、要素へのアクセス、および基本的な操作を理解しています。また、文字列操作とポインタ操作についても基本的な理解を示しています。\n\nこの問題では、以下の点を評価します。\n\n- 関数を通して配列を操作する能力\n- 動的なメモリ確保と解放\n- ポインタによるサイズの受け渡し\n- 異なるサイズの配列を扱う能力\n\nこの問題は、学習者が既存の知識を応用し、より複雑な問題に取り組むための良い練習となります。",
  "examples": [
    {
      "input": "arr1 = {1, 2, 3}, size1 = 3, arr2 = {4, 5, 6}, size2 = 3",
      "output": "{1, 2, 3, 4, 5, 6}, merged_size = 6",
      "explanation": "2つの配列{1, 2, 3}と{4, 5, 6}が結合され、新しい配列{1, 2, 3, 4, 5, 6}が作成されます。merged_sizeには結合後の配列のサイズ6が格納されます。"
    },
    {
      "input": "arr1 = {}, size1 = 0, arr2 = {1, 2}, size2 = 2",
      "output": "{1, 2}, merged_size = 2",
      "explanation": "空の配列と{1, 2}が結合され、新しい配列{1, 2}が作成されます。merged_sizeには2が格納されます。"
    },
    {
      "input": "arr1 = {1, 2}, size1 = 2, arr2 = {}, size2 = 0",
      "output": "{1, 2}, merged_size = 2",
      "explanation": "{1, 2}と空の配列が結合され、新しい配列{1, 2}が作成されます。merged_sizeには2が格納されます。"
    }
  ],
  "learning_objectives": [
    "動的メモリ確保",
    "ポインタ",
    "配列操作",
    "関数"
  ]
}