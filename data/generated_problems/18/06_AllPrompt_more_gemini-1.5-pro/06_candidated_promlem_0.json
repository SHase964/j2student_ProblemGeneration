{
  "problem_id": "No7.c",
  "difficulty": 7,
  "description": "二次元配列（行列）を扱う際に、頻繁に必要となる操作を関数として実装する練習です。\n\n(1) n行m列の行列（int **matrix）を受け取り、転置行列を新たに作成して返す関数 transpose_matrix(int **matrix, int n, int m) を作成しなさい。\nただし、転置行列はm行n列の行列であり、元の行列の行と列を入れ替えたものです。\n関数の戻り値は、転置行列へのポインタ（int **）とします。\n\n(2) n行n列の正方行列（int **matrix）を受け取り、対角成分の和を計算して返す関数 trace(int **matrix, int n) を作成しなさい。\n\n(3) main関数内で、キーボードから行列の行数と列数（nとm）を入力し、n行m列の行列を動的に確保しなさい。\n行列の各要素には、0から99までの乱数を代入しなさい。\n(1)で作成した関数 transpose_matrix を使用して転置行列を作成し、その結果を表示しなさい。\n次に、n行n列の正方行列を動的に確保し、同様に乱数を代入し、(2)で作成した関数 trace を使用して対角成分の和を計算し、その結果を表示しなさい。\n\nヒント：二次元配列を関数に渡す際は、int **matrix のようにポインタのポインタを使用します。\nまた、動的に確保したメモリは、使用後に必ず free する必要があることに注意してください。",
  "reason": "学習者は、一次元配列の動的確保、要素へのアクセス、反復処理、偶数判定といった基本的な操作を理解し、正しく実装できています。また、二次元配列についても動的確保、要素へのアクセス、反復処理を問題なく行えています。さらに、文字列操作、特に文字列の連結についても理解し、実装できています。これらのことから、学習者はC言語の基礎的な構文、配列、ポインタ、文字列操作について十分な理解があると判断できます。\n\n次のステップとして、より複雑な問題に挑戦することで、学習者の理解を深め、応用力を高めることが重要です。具体的には、関数化、モジュール化、アルゴリズムの設計といった、より高度なプログラミングスキルを習得する必要があります。\n\nこの問題では、二次元配列を操作する関数を自作することで、関数化とモジュール化の理解を深めます。また、転置行列や対角成分の和といった線形代数の基本的な操作を実装することで、アルゴリズムの設計能力を養います。さらに、動的に確保したメモリの解放を適切に行う必要があるため、メモリ管理の重要性についても再確認できます。",
  "examples": [
    {
      "input": "3 4\n",
      "output": "(1) 転置行列：\n[0][0]: 15\n[0][1]: 78\n[0][2]: 32\n[1][0]: 4\n[1][1]: 95\n[1][2]: 61\n[2][0]: 23\n[2][1]: 11\n[2][2]: 7\n[3][0]: 88\n[3][1]: 42\n[3][2]: 59\n\n(2) 対角成分の和：\n168",
      "explanation": "3行4列の行列を入力し、転置行列と、3行3列の正方行列の対角成分の和を出力する例です。乱数によって値は変化します。"
    }
  ],
  "learning_objectives": [
    "二次元配列の操作",
    "関数の作成",
    "動的メモリ確保",
    "線形代数の基本操作",
    "アルゴリズムの設計"
  ]
}